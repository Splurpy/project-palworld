<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pal Entries</title>
        <link rel="stylesheet" href="./styles.css">

        <script> // Mode defs and dbPath def
            const parentMode = 'parent'; // calculate the other parent when given the child and one parent
            const childMode = 'child'; // calculate the child of two chosen parents
            var mode = childMode;

            // filepath to the database file
            let dbPath = '/project-palworld/db/paldb.db';
        </script>
    </head>

    <header>
        PALCHECK
        <div class="subText">~ PALWORLD BREEDING CALCULATOR ~</div>
        <div class="modeWrapper">
            <label class="modeLabel" for="mode">Mode:</label>
            <select class="modeDropdown" name="mode" id="mode" onchange="updateModeLabels();">
                <option value="child" class="dropdownOption">Child-Oriented</option>
                <option value="parent" class="dropdownOption">Parent-Oriented</option>
            </select>
            <p class="helpIcon" title="Help">?</p>
        </div>
        <hr>
    </header>

    <body>
        <div class="appContainer">
            <div class="centerer">
                <div class=" searchWrapper" id="search-1">
                    <div class="label">
                        Parent 1
                    </div>
                    <div class="searchPanel">
                        <div class="topPortion">
                            <input type="text" class="searchBox" id="searchBox" placeholder="Search by name..."
                                oninput="filterResults(this.parentElement.parentElement.parentElement);">
                        </div>
                        <div id="palContainer" class="container palContainer"></div>
                        <script src="./dist/sql-wasm.js"></script>
                        <script> // Load entries and search panels

                            var palArray = new Array();
                            var uniqueCombos = new Array();
                            const config = {
                                locateFile: filename => `/project-palworld/dist/${filename}`
                            };

                            initSqlJs(config).then(function (SQL) {
                                // Pal class definition
                                class Pal {
                                    constructor(tieOrder, dexNum, name, rarity, elem1, elem2, sprintSpeed, breedPower,
                                        kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming) {
                                        this.tieOrder = tieOrder;
                                        this.dexNum = dexNum;
                                        this.name = name;
                                        this.rarity = rarity;
                                        this.elem1 = elem1;
                                        this.elem2 = elem2;
                                        this.sprintSpeed = sprintSpeed;
                                        this.breedPower = breedPower;

                                        this.kindling = kindling;
                                        this.planting = planting;
                                        this.handiwork = handiwork;
                                        this.lumbering = lumbering;
                                        this.medicine = medicine;
                                        this.transporting = transporting;
                                        this.watering = watering;
                                        this.genElec = genElec;
                                        this.gathering = gathering;
                                        this.mining = mining;
                                        this.cooling = cooling;
                                        this.farming = farming;
                                    }

                                    // Reading query as pal objects
                                    static async readPals() {
                                        try {
                                            const response = await fetch(dbPath);
                                            const buffer = await response.arrayBuffer();
                                            const db = new SQL.Database(new Uint8Array(buffer));
                                            const query = "SELECT pd.IndexOrder, bp.DexNum, bp.Name, pd.Rarity, pd.ElementType1, pd.ElementType2, pd.RideSprintSpeed, bp.Power, pd.WorkSuitability_EmitFlame, pd.WorkSuitability_Watering, pd.WorkSuitability_Seeding, pd.WorkSuitability_GenerateElectricity, pd.WorkSuitability_Handcraft, pd.WorkSuitability_Collection, pd.WorkSuitability_Deforest, pd.WorkSuitability_Mining, pd.WorkSuitability_ProductMedicine, pd.WorkSuitability_Cool,  pd.WorkSuitability_Transport,  pd.WorkSuitability_MonsterFarm FROM breeding_power bp JOIN pal_data pd ON bp.Name = pd.Name ORDER BY bp.name ASC";
                                            const rows = db.exec(query);

                                            if (rows.length > 0) {

                                                rows[0].values.forEach(row => {
                                                    const [tieOrder, dexNum, name, rarity, elem1, elem2, sprintSpeed, breedPower, kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming] = row;
                                                    const fElem1 = elem1.replace("EPalElementType::", "").toLowerCase();
                                                    const fElem2 = elem2.replace("EPalElementType::", "").toLowerCase();
                                                    palArray[tieOrder - 1] = new Pal(tieOrder, dexNum, name, rarity, fElem1, fElem2, sprintSpeed, breedPower, kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming);
                                                });


                                                palArray.sort(function sortPals(pal1, pal2) {
                                                    let name1 = pal1.name.toLowerCase();
                                                    let name2 = pal2.name.toLowerCase();

                                                    if (name1 < name2) return -1;
                                                    else if (name1 > name2) return 1;
                                                    else return 0;
                                                });

                                                console.log(`[DEBUG] Successfully read ${palArray.length} entries`);
                                            } else {
                                                console.log("[DEBUG] ERROR: No data retrieved");
                                                throw new Error("No data retrieved");
                                            }
                                        } catch (error) {
                                            console.error(error);
                                            throw error;
                                        }

                                        const response = await fetch(dbPath);
                                        const buffer = await response.arrayBuffer();
                                        const db = new SQL.Database(new Uint8Array(buffer));
                                        const query = "SELECT * FROM unique_combos";
                                        const rows = db.exec(query);

                                        if (rows.length > 0) {
                                            rows[0].values.forEach(row => {
                                                const [parent1, parent2, child] = row;
                                                uniqueCombos.push([parent1, parent2, child]);
                                            });
                                        }
                                    }
                                }

                                (async function () {
                                    try {
                                        await Pal.readPals();
                                        const palContainer = document.getElementById('palContainer');
                                        let selectedPalEntry1 = null;
                                        let selectedPalEntry2 = null;

                                        palArray.forEach(pal => {

                                            const palEntry = document.createElement('div');
                                            palEntry.classList.add('palEntry');
                                            palEntry.id = `entry-${pal.name}`;

                                            const palImg = document.createElement('img');
                                            palImg.src = `./resource/img/pal/${pal.name}.png`;
                                            palImg.classList.add('palImg');

                                            const palName = document.createElement('div');
                                            palName.classList.add('palName');
                                            palName.textContent = pal.name;

                                            const shineBox = document.createElement('div');
                                            palEntry.classList.add('shineBox');

                                            const element = document.createElement('img');
                                            element.id = `${pal.name}.elem1`;
                                            element.src = `./resource/img/elem/${pal.elem1}.png`;
                                            element.classList.add('element', `${pal.elem1}`);
                                            element.title = pal.elem1.charAt(0).toUpperCase() + pal.elem1.slice(1);
                                            if (element.title === 'Leaf') element.title = 'Grass';
                                            else if (element.title === 'Electricity') element.title = 'Electric';
                                            else if (element.title === 'Earth') element.title = 'Ground';
                                            else if (element.title === 'Normal') element.title = 'Neutral';

                                            if (pal.elem2 !== 'none') {
                                                const element2 = document.createElement('img');
                                                element2.id = `${pal.name}.elem2`;
                                                element2.src = `./resource/img/elem/${pal.elem2}.png`;
                                                element2.classList.add('element', 'secondary', `${pal.elem2}`);
                                                element2.title = pal.elem2.charAt(0).toUpperCase() + pal.elem2.slice(1);
                                                if (element2.title === 'Leaf') element2.title = 'Grass';
                                                else if (element2.title === 'Electricity') element2.title = 'Electric';
                                                else if (element2.title === 'Earth') element2.title = 'Ground';
                                                else if (element2.title === 'Normal') element2.title = 'Neutral';
                                                palEntry.appendChild(element2);
                                            }

                                            // Breeding power
                                            palEntry.setAttribute('data-breedPower', pal.breedPower);

                                            // new div for work plate
                                            const workPlate = document.createElement('div');
                                            workPlate.classList.add('workPlate');

                                            // Work Suitabilities
                                            const workImg = document.createElement('img');
                                            workImg.classList.add('workImg');

                                            const work_suitabilities = ['kindling', 'watering', 'planting', 'genElec', 'handiwork', 'gathering', 'lumbering', 'mining', 'medicine', 'cooling', 'transporting', 'farming'];

                                            let workImgIndex = 0;
                                            for (let i = 0; i < work_suitabilities.length; i++) {
                                                const suitabilityImg = document.createElement('img');
                                                suitabilityImg.src = `./resource/img/work/${work_suitabilities[i]}.png`;
                                                suitabilityImg.classList.add('workImg', work_suitabilities[i]);
                                                suitabilityImg.title = work_suitabilities[i].charAt(0).toUpperCase() + work_suitabilities[i].slice(1);

                                                if (suitabilityImg.title === 'GenElec') suitabilityImg.title = 'Electricity Generation';
                                                else if (suitabilityImg.title === 'Medicine') suitabilityImg.title += ' Production';
                                                if (pal[work_suitabilities[i]] == 0) {
                                                    suitabilityImg.style.filter = 'grayscale(100%)';
                                                }
                                                if (pal[work_suitabilities[i]] !== 0) {
                                                    suitabilityImg.style.setProperty('--index', workImgIndex++);

                                                    const workLvl = document.createElement('p');
                                                    workLvl.innerText = pal[work_suitabilities[i]];

                                                    workLvl.classList.add('workLvl', work_suitabilities[i]);
                                                    workLvl.style.setProperty('--index', workImgIndex - 1);
                                                    workPlate.appendChild(workLvl);
                                                    palEntry.appendChild(suitabilityImg);
                                                }

                                            }

                                            palEntry.appendChild(palImg);
                                            palEntry.appendChild(element);
                                            palEntry.appendChild(palName);
                                            palEntry.appendChild(shineBox);
                                            palEntry.appendChild(workPlate);
                                            palContainer.appendChild(palEntry);
                                        });
                                        let searchWrapper1 = document.querySelector('.searchWrapper');
                                        let searchWrapper2 = searchWrapper1.cloneNode(true);
                                        searchWrapper2.id = 'search-2';
                                        searchWrapper2.getElementsByClassName('label')[0].textContent = 'Parent 2';
                                        document.getElementsByClassName('appContainer')[0].children[0].appendChild(searchWrapper2);
                                        addFilters();
                                        addSelectHandlers([searchWrapper1, searchWrapper2]);
                                    } catch (error) {
                                        console.error(error);
                                    }
                                })();
                            });
                        </script>
                    </div>
                    <div class="filtersMenuHitbox">
                        <div class="filtersMenu">
                            <div class="filtersMenuTab">
                                <p class="tabArrow">
                                    &#9660;
                                </p>
                            </div>
                            <div class="hideyMan"></div>
                            <div class="filterImage">
                                <div class="filterTriangle">
                                    &#x25BC;

                                    <div class="filterBar">
                                        &#x2758;

                                    </div>
                                </div>
                            </div>
                            <div class="filtersContainer container">
                                <div class="elementFilterContainer"></div>
                                <div class="workFilterContainer"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="resultField">
                    <div class="resultLabel">
                        Child
                    </div>
                    <div class="resultContainer"></div>
                </div>
            </div>
        </div>
        <div class="fullGuideContainer">
            <h1 class="guideLabel">
                GUIDE
            </h1>
            <div class="guideContainer">
                <h1 class="guideLabel guideHeader">
                    Summary
                    <hr>
                </h1>
                <p class="text">
                <p class="text emphasizedText">
                    This is a tool used to calculate one of two things:
                </p>
                <p class="text italicText">
                    <br>
                    1) The child resulting from breeding two pals (Child-Oriented)
                    <br>
                    2) The possible parents one can use to breed a desired child (Parent-Oriented)
                    <br>
                    <br>
                    <br>
                <p class="text emphasizedText">
                    Simply click on a pal to select it. Clicking the pal again will deselect
                    it.
                    <br>
                </p>
                <p class="text detailsText italicText">
                    -- NOTE: Pals will not deselect until they are manually deselected, or until another pal within the
                    same panel is selected.
                </p>
                <br>
                <p class="text">
                    Each panel (Except the results panel) may also be expanded to show an additional column of pals.
                    <br>
                    To do this, simply click and drag from the bottom-right corner of a search panel.
                </p>
                <br>
                <p class="text italicText">
                    *For more information on how to use each mode, see the below section titled "Modes"
                </p>
                <br>
            </div>
            <div class="guideContainer">
                <h1 class="guideLabel guideHeader">
                    Modes
                    <hr>
                    <p class="text emphaiszedText">
                        *To switch between modes, use the dropdown menu labaled "Mode" at the top of the page.
                    </p>
                    <div class="splitContainer">
                        <div class="guideContainer">
                            <p class="subHeaderText">
                                Child-Oriented Mode
                            </p>
                            <hr>
                            <p class="italicText text">
                                1) Select the first parent pal from the "Parent 1" Panel
                                <br>
                                <br>
                                <br>
                                2) Select the second parent pal from the "Parent 2" Panel
                                <br>
                                <br>
                                <br>
                                3) The "Child" Panel now contains the resulting child from breeding the two chosen
                                parents
                            </p>

                        </div>
                        <div class="guideContainer">
                            <p class="subHeaderText">
                                Parent-Oriented Mode
                            </p>
                            <hr>
                            <p class="italicText text">
                                1) Select the pal you want to breed/hatch
                                <br>
                                <br>
                                <br>
                                2) Select a potential parent pal from the "Parent 1" Panel
                                <br>
                            <p class="italicText text detailsText">
                                -- NOTE: The "Parent 1" Panel will only show pals that may be bred together to result in
                                the pal chosen in the "Child" Panel.
                            </p>
                            <p class="italicText text">
                                <br>
                                3) The "Parent 2" Panel is now populated with all possible parent pals that when bred
                                with the chosen "Parent1" pal, will result in an egg containing the pal selected in the
                                "Child" Panel
                                <br>
                                <br>
                            </p>
                        </div>
                    </div>
                </h1>
            </div>
            <div class="guideContainer">
                <h1 class="guideLabel guideHeader">
                    Filtering Search Panels
                </h1>
                <hr>
                <p class="emphasizedText text">
                    Each search panel may be filtered by element/type and work level.
                    <br>
                    To access a panel's filters menu, hover your cursor over the blue tab at the bottom of the panel.
                </p>
                <p class="text italicText">
                    *Pals will be "filtered out" if they don't meet the exact criteria selected via filtering.
                </p>
                <div class="splitContainer">
                    <div class="guideContainer">
                        <p class="subHeaderText text">
                            Filtering By Element
                        </p>
                        <hr>
                        <p class="text italicText">
                            1) Click on any of the element/type icons in the filters menu to add it to the list of
                            acceptable elements. Click an icon again to deselect it.
                            <br>
                        </p>
                        <p class="text detailsText italicText">
                            -- NOTE: Pals are only shown if they are of every selected type. Selecting any more than 2
                            types will filter out every pal, as no pal is of more than 2 types.
                        </p>
                        <br>
                    </div>
                    <div class="guideContainer">
                        <p class="subHeaderText text">
                            Filtering By Work Type/Level
                        </p>
                        <hr>
                        <p class="text italicText">
                            1) Click on any of the work icons in the filters menu to add it to the list of desired work
                            suitabilities. Click an icon again to deselect it.
                            <br>
                            <br>
                            2) To set the minimum level of a work suitability, use the input field next to the work
                            icon.
                            <br>
                            You may manually type levels (1-4), or you may
                            use the arrow keys to scroll through them.
                            <br>
                        </p>
                        <p class="text italicText detailsText">
                            -- NOTE: Like when filtering by element/type, pals are "filtered out" if they don't meet
                            every selected criteria within the filters menu.
                        </p>
                        <br>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <hr style="width: 99%;">
            <br>
            <p class="text subHeaderText offset footerText italicText">
                | Xavier Reardon
                <br>
                <br>
            </p>
            <p class="text italicText emphasizedText offset footerText">
                **This site nor its author are affiliated with Pocket Pair, Inc.
            </p>
        </footer>
        <script>
            function addFilters() {
                const work_suitabilities = ['kindling', 'watering', 'planting', 'genElec', 'handiwork', 'gathering', 'lumbering', 'mining', 'medicine', 'cooling', 'transporting', 'farming'];
                const elements = ['fire', 'water', 'leaf', 'earth', 'electricity', 'normal', 'dark', 'ice', 'dragon'];

                let wrappers = document.querySelectorAll('.searchWrapper');
                wrappers.forEach(function (wrapper) {
                    let filtersContainer = wrapper.getElementsByClassName('filtersContainer')[0];
                    let elementFilterContainer = filtersContainer.getElementsByClassName('elementFilterContainer')[0];
                    let workFilterContainer = filtersContainer.getElementsByClassName('workFilterContainer')[0];

                    elements.forEach(function (elementValue) {

                        let elementFilterButton = document.createElement('img');
                        elementFilterButton.src = `./resource/img/elem/${elementValue}.png`;
                        elementFilterButton.classList.add('elementFilterButton', `${elementValue}`);

                        elementFilterButton.title = elementValue.charAt(0).toUpperCase() + elementValue.slice(1);
                        if (elementFilterButton.title === 'Leaf') elementFilterButton.title = 'Grass';
                        else if (elementFilterButton.title === 'Electricity') elementFilterButton.title = 'Electric';
                        else if (elementFilterButton.title === 'Earth') elementFilterButton.title = 'Ground';
                        else if (elementFilterButton.title === 'Normal') elementFilterButton.title = 'Neutral';

                        elementFilterButton.addEventListener('click', () => {
                            elementFilterButton.classList.toggle('selected');
                            filterResults(wrapper); // Trigger filtering algorithm
                        });


                        elementFilterContainer.appendChild(elementFilterButton);
                    });

                    work_suitabilities.forEach(function (suitability) {
                        let workFilterButtonWrapper = document.createElement('div');
                        workFilterButtonWrapper.classList.add('workFilterButtonWrapper');

                        let workFilterButton = document.createElement('img');
                        workFilterButton.src = `./resource/img/work/${suitability}.png`;
                        workFilterButton.classList.add('workFilterButton', `${suitability}`);
                        workFilterButtonWrapper.appendChild(workFilterButton);

                        workFilterButtonWrapper.title = suitability.charAt(0).toUpperCase() + suitability.slice(1);
                        if (workFilterButtonWrapper.title === 'GenElec') workFilterButtonWrapper.title = 'Electricity Generation';
                        else if (workFilterButtonWrapper.title === 'Medicine') workFilterButtonWrapper.title += ' Production';

                        workFilterButton.addEventListener('click', () => {
                            event.target.parentElement.classList.toggle('selected');
                            filterResults(wrapper);
                        });

                        let minLevelInput = document.createElement('input');
                        minLevelInput.placeholder = '1';
                        minLevelInput.maxLength = 1;
                        minLevelInput.onkeydown = function handleKeys(e) {
                            let acceptedKeys = [8, 37, 38, 39, 40, 49, 50, 51, 52];
                            if (!acceptedKeys.includes(e.keyCode)) e.preventDefault();
                            else if (this.value.length === 1 || this.value.length === 0) {
                                // e.preventDefault();
                                switch (e.keyCode) {
                                    case 8:
                                        this.value = '';
                                        break;
                                    case 39:
                                    case 38:
                                        if (parseInt(this.value) < 4) this.value = parseInt(this.value) + 1;
                                        else if (this.value.length === 0) this.value = 2;
                                        break;
                                    case 37:
                                    case 40:
                                        if (parseInt(this.value) > 2) this.value = parseInt(this.value) - 1;
                                        else if (parseInt(this.value) === 2) this.value = '';
                                        break;
                                }
                            };
                        };

                        minLevelInput.addEventListener('keydown', () => {
                            if (event.target.parentElement.classList.contains('selected')) filterResults(wrapper);
                        })

                        minLevelInput.classList.add('minLevelInput', `${suitability}`);
                        workFilterButtonWrapper.appendChild(minLevelInput);
                        workFilterContainer.appendChild(workFilterButtonWrapper);
                    });

                })
            }
        </script>
        <script>
            function filterResults(wrapper) {
                console.log('[DEBUG] filtering entries');
                let input, filter, palContainer, palEntries, i;
                input = wrapper.getElementsByClassName("searchBox")[0];
                filter = input.value.toUpperCase();
                palContainer = wrapper.getElementsByClassName("palContainer")[0];
                palEntries = palContainer.getElementsByClassName("palEntry");
                let selectedElements = wrapper.querySelectorAll('.elementFilterButton.selected');
                let selectedWorkFilters = wrapper.querySelectorAll('.workFilterButtonWrapper.selected');

                for (i = 0; i < palEntries.length; i++) {
                    let currEntry = palEntries[i];
                    let palName = currEntry.getElementsByClassName("palName")[0];
                    let txtValue = palName.textContent || palName.innerText;
                    let shouldDisplay = true;
                    let conditions = [];

                    // Check if the pal entry matches the search filter
                    if (txtValue.toUpperCase().indexOf(filter) === -1) {
                        conditions.push('false');
                    }

                    // Filter by element
                    selectedElements.forEach(selectedElement => {
                        let elem1 = currEntry.getElementsByClassName(`element`)[0];
                        let elem2 = currEntry.getElementsByClassName(`element`)[1];

                        if (!(elem1 && elem1.classList.contains(selectedElement.classList[1])) &&
                            !(elem2 && elem2.classList.contains(selectedElement.classList[1]))) {
                            conditions.push('false');
                        }
                    });

                    // Filter by work suitability + level
                    // For each wrapper, get its type and minimum level - DONE
                    // Then, compare that min level to the current palEntry's level for that type - DONE
                    // Set shouldDisplay accordingly - WIP, Currently operates only based on most recent one, collect all into an array and if any are false, set false
                    let currPal = palEntries[i];
                    let workPlate = currPal.getElementsByClassName('workPlate')[0];
                    selectedWorkFilters.forEach(workWrapper => {
                        let inputBox = workWrapper.getElementsByClassName('minLevelInput')[0];
                        let minLvl = inputBox.value;
                        if (!inputBox.value) minLvl = 0;

                        let workEntry = workPlate.getElementsByClassName(`${inputBox.classList[1]}`);
                        workEntry = workEntry[0];
                        // If this palEntry has the following selected workType
                        if (workEntry) {
                            let workLvl = workEntry.textContent;
                            if (workLvl >= minLvl) conditions.push('true');
                            else conditions.push('false');
                        } else {
                            conditions.push('false');
                        }
                    });

                    // Filter panel2 when in parent mode
                    let wrapperId = currEntry.parentElement.parentElement.parentElement.id;
                    if (mode === parentMode && wrapperId === 'search-1' && document.querySelector('#search-1').getElementsByClassName('selected').length > 0) {

                        let childPanel = document.querySelector('#search-1');
                        if (childPanel.querySelectorAll('.palEntry.selected').length > 0) {
                            let parent1Panel = document.querySelector('#search-2');
                            let childEntry = childPanel.getElementsByClassName('selected')[0];
                            let childName = childEntry.getElementsByClassName('palName')[0].textContent;


                            // Only show elements within parent1Panel (#search-2) that are possible parents of the selected child
                            let allBreedPowers = palArray.map((pal) => pal.breedPower);


                            let childPower = parseInt(childEntry.getAttribute('data-breedPower'));
                            let parentPower = parseInt(currEntry.getAttribute('data-breedPower'));

                            let filteredBreedPowers = [];
                            let exactPower;
                            allBreedPowers.forEach(power => {
                                if (Math.floor((parentPower + power + 1) / 2) === childPower) exactPower = power;
                            });

                            // Filter the breedPowers to get the ones within the range of lowerBound and upperBound
                            filteredBreedPowers = allBreedPowers.filter(breedPower =>
                                breedPower >= exactPower - 10 && breedPower <= exactPower + 10
                            );

                            let resultNames = [];

                            let unique = getUniqueParents(childEntry.getElementsByClassName('palName')[0].textContent);
                            if (unique.length > 0) {
                                let entryElement = parent1Panel.querySelector(`[data-breedpower='${parentPower}']`);
                                if (parentPower === 1240 && currEntry.id.includes('Special')) {
                                    entryElement = Array.from(parent1Panel.querySelectorAll(`[data-breedpower='${parentPower}']`))[1];
                                }

                                if (unique.includes(palName.textContent)) {
                                    if (entryElement.classList.contains('invalidParent')) entryElement.classList.toggle('invalidParent');
                                } else {
                                    if (!entryElement.classList.contains('invalidParent')) entryElement.classList.toggle('invalidParent');
                                }

                            } else {
                                filteredBreedPowers.forEach((filteredPower) => {
                                    resultNames.push(palArray[allBreedPowers.indexOf(filteredPower)].name);
                                });

                                let entryElement = parent1Panel.querySelector(`[data-breedpower='${parentPower}']`);
                                if (parentPower === 1240 && currEntry.id.includes('Special')) {
                                    entryElement = Array.from(parent1Panel.querySelectorAll(`[data-breedpower='${parentPower}']`))[1];
                                }

                                if (resultNames.length > 0) {
                                    if (entryElement.classList.contains('invalidParent')) entryElement.classList.toggle('invalidParent');
                                } else {
                                    if (!entryElement.classList.contains('invalidParent')) entryElement.classList.toggle('invalidParent');
                                }
                            }
                        }
                    } else if ((mode === parentMode && wrapperId === 'search-1' && document.querySelector('#search-1').getElementsByClassName('selected').length < 1) || mode === childMode) {
                        // Unhide hidden entries
                        let parent1Panel = document.querySelector('#search-2');
                        let currPalObject = palArray[i];
                        let parent1PanelEntry = Array.from(parent1Panel.querySelectorAll(`[data-breedpower='${currPalObject.breedPower}']`))[0];
                        if (currPalObject.breedPower === 1240 && currEntry.id.includes('Special')) {
                            parent1PanelEntry = Array.from(parent1Panel.querySelectorAll(`[data-breedpower='${currPalObject.breedPower}']`))[1];
                        }

                        if (parent1PanelEntry.classList.contains('invalidParent')) {
                            parent1PanelEntry.classList.toggle('invalidParent');
                        }
                    }

                    // TODO INVESTIGATE STRANGE BEHAVIOR - NOT FILTERING PROPERLY

                    // Display entry if it contains adequate levels
                    if (conditions.includes('false')) shouldDisplay = false;

                    // Update the display of the pal entry
                    if (shouldDisplay) {
                        palEntries[i].style.display = "";
                    } else {
                        palEntries[i].style.display = "none";
                    }
                }
            }

        </script>
        <script>
            function addSelectHandlers(wrappers) {
                wrappers.forEach(function (wrapper, i) {
                    let palContainer = wrapper.getElementsByClassName("palContainer")[0];
                    let palEntries = Array.from(palContainer.getElementsByClassName("palEntry"));
                    palEntries.forEach(palEntry => {

                        palEntry.addEventListener('click', () => {
                            const currentPalEntry = event.currentTarget;
                            currentPalEntry.classList.toggle('selected');
                            let selectedPalEntry = eval(`this.selectedPalEntry${i + 1}`);
                            if (selectedPalEntry && selectedPalEntry !== currentPalEntry) {
                                selectedPalEntry.classList.remove('selected');
                            }

                            selectedPalEntry = currentPalEntry.classList.contains('selected') ? currentPalEntry : null;
                            if (i == 0) {
                                selectedPalEntry1 = selectedPalEntry;
                            } else {
                                selectedPalEntry2 = selectedPalEntry;
                            }
                            filterResults(wrapper);
                            calculateResult();
                        });
                    });
                });
            }
        </script>
        <script>
            function removeFadeOut(element) {
                element.classList.add('removed');
                setTimeout(function () {
                    element.parentNode.removeChild(element);
                }, 300);
            }

            // Array of combos (Length 3 array of parent1, parent2, and child)
            // Pass in parent1 and parent2 as palNames (strings), return null if not unique combo
            function getUniqueCombo(parent1, parent2) {
                let result = null;
                uniqueCombos.forEach((combo) => {
                    let parents = [combo[0], combo[1]];
                    if ((parents[0] === parent1 && parents[1] === parent2) || (parents[0] === parent2 && parents[1] === parent1)) {
                        result = combo[2];
                    }
                });

                return result;
            }

            // Array of combos (Length 3 array of parent1, parent2, and child)
            // Pass in parent1, child as palNames (strings), return null if not a unique combo
            function getUniqueParent(parent1, child) {
                let result = null;
                uniqueCombos.forEach((combo) => {
                    let parents = [combo[0], combo[1]];
                    if (child === combo[2]) {
                        if (parent1 === combo[0]) {
                            result = combo[1];
                        }
                        else if (parent1 === combo[1]) {
                            result = combo[0];
                        }
                    }
                });

                return result;
            }

            // Array of combos (Length 3 array of parent1, parent2, and child)
            // Pass in child as palName (string), return null if not a unique combo, return possible parent combinations
            function getUniqueParents(child) {
                let result = [];
                uniqueCombos.forEach((combo) => {
                    let parents = [combo[0], combo[1]];
                    if (child === combo[2]) {
                        result = [combo[0], combo[1], child];
                    }
                });
                return result;
            }


            function calculateResult() {
                let field = document.getElementsByClassName('resultField')[0];
                field = field.getElementsByClassName('resultContainer')[0];
                let selectedPals = [];
                selectedPals = Array.from(document.getElementsByClassName('palEntry selected'));

                // Two pals have NOT yet been selected
                if (selectedPals.length < 2) {
                    if (field.childElementCount > 0) {
                        Array.from(field.children).forEach((child) => {
                            removeFadeOut(child);
                        })
                    }
                }
                // Two pals have been selected
                else {
                    let palNames = [selectedPals[0].getElementsByClassName('palName')[0].textContent, selectedPals[1].getElementsByClassName('palName')[0].textContent];
                    let unique;
                    let resultName = '';

                    if (mode === childMode) {
                        unique = getUniqueCombo(palNames[0], palNames[1]);
                        if (unique) resultName = unique;
                        else {
                            let breedPowers = selectedPals.map((palEntry) => palEntry.getAttribute('data-breedPower'));
                            let resultBreedPower = Math.floor((parseInt(breedPowers[0]) + parseInt(breedPowers[1]) + 1) / 2);

                            let allBreedPowers = palArray.map((pal) => pal.breedPower);

                            let nearest = allBreedPowers.reduce(function (prev, curr) {
                                return (Math.abs(curr - resultBreedPower) < Math.abs(prev - resultBreedPower) ? curr : prev);
                            });
                            resultName = palArray[allBreedPowers.indexOf(nearest)].name;
                        }

                        if (field.childElementCount > 0) {
                            removeFadeOut(field.children[0]);
                        }

                        let resultEntry = document.getElementById(`entry-${resultName}`).cloneNode(true);
                        if (resultEntry.classList.contains('selected')) {
                            resultEntry.classList.toggle('selected');
                        }
                        resultEntry.classList.toggle('result');
                        resultEntry.style.display = 'block';
                        field.appendChild(resultEntry);

                    }
                    else { // Parent mode logic
                        if (field.childElementCount > 0) {
                            Array.from(field.children).forEach((child) => {
                                field.removeChild(child);
                            });
                        }
                        unique = getUniqueParent(palNames[1], palNames[0]);
                        if (unique !== null) {
                            let resultEntry = document.getElementById(`entry-${unique}`).cloneNode(true);
                            if (resultEntry.classList.contains('selected')) {
                                resultEntry.classList.toggle('selected');
                            }
                            resultEntry.classList.toggle('result');
                            resultEntry.style.display = 'block';
                            field.appendChild(resultEntry);
                        }
                        else {
                            let breedPowers = selectedPals.map((palEntry) => palEntry.getAttribute('data-breedPower'));
                            let childPower = parseInt(breedPowers[0]); // C is breedPowers[0]
                            let parentPower = parseInt(breedPowers[1]); // p1 is breedPowers[1]

                            let allBreedPowers = palArray.map((pal) => pal.breedPower);

                            let filteredBreedPowers = [];
                            let exactPower;
                            allBreedPowers.forEach(power => {
                                if (Math.floor((parentPower + power + 1) / 2) === childPower) exactPower = power;
                            });

                            // Filter the breedPowers to get the ones within the range of lowerBound and upperBound
                            filteredBreedPowers = allBreedPowers.filter(breedPower => breedPower >= exactPower - 10 && breedPower <= exactPower + 10);

                            // Find the names corresponding to the filtered breedPowers
                            let resultNames = [];
                            let gumossCount = 0;
                            filteredBreedPowers.forEach((filteredPower) => {
                                if (filteredPower === 1240) {
                                    if (gumossCount === 1) {
                                        resultNames.push(palArray.filter(palObject => palObject.name.includes('Special'))[0].name);

                                    } else resultNames.push(palArray[allBreedPowers.indexOf(filteredPower)].name);

                                    gumossCount++;

                                } else resultNames.push(palArray[allBreedPowers.indexOf(filteredPower)].name);
                            });


                            resultNames.forEach(resultName => {
                                let resultEntry = document.getElementById(`entry-${resultName}`).cloneNode(true);
                                if (resultEntry.classList.contains('selected')) {
                                    resultEntry.classList.toggle('selected');
                                }
                                resultEntry.classList.toggle('result');
                                resultEntry.style.display = 'block';
                                if (!(palNames[0].includes('Gumoss') && !palNames[0].includes('Special') && resultName.includes('Special'))) {
                                    field.appendChild(resultEntry);
                                }
                                else if ((palNames[0].includes('Gumoss') && !palNames[1].includes('Special') && resultName.includes('Special'))) {
                                    field.appendChild(resultEntry);
                                }
                            })
                        }
                    }

                }
            }
        </script>
        <script>
            function updateModeLabels() {
                let label1 = document.getElementById('search-1').getElementsByClassName('label')[0];
                let label2 = document.getElementById('search-2').getElementsByClassName('label')[0];
                let resultField = document.getElementsByClassName('resultField')[0];
                let resultLabel = resultField.getElementsByClassName('resultLabel')[0];

                mode = document.getElementsByName('mode')[0].value;

                if (mode === childMode) {
                    label1.textContent = 'Parent 1';
                    label2.textContent = 'Parent 2';
                    resultLabel.textContent = 'Child';
                } else {
                    label1.textContent = 'Child';
                    label2.textContent = 'Parent 1';
                    resultLabel.textContent = 'Parent 2';
                }
                resultField.classList.toggle('parentMode');
                filterResults(document.getElementById('search-1'));
                calculateResult();
            }
        </script>
        <script> // Add event handler to help icon/button
            let helpIcon = document.getElementsByClassName('helpIcon')[0];
            helpIcon.addEventListener('click', () => {
                document.getElementsByClassName('fullGuideContainer')[0].scrollIntoView({ behavior: 'smooth' });
            });
        </script>
    </body>

</html>