<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pal Entries</title>
        <link rel="stylesheet" href="./styles.css">
    </head>

    <body>
        <div class="searchWrapper">
            <div class="searchPanel">
                <div class="topPortion">
                    <input type="text" class="searchBox" id="searchBox" placeholder="Search by name..."
                        oninput="filterResults(this.parentElement.parentElement);">
                </div>
                <div id="palContainer" class="container palContainer"></div>
                <script src="./dist/sql-wasm.js"></script>
                <script> // Configuration for SQL.js
                    var palArray = new Array();
                    var uniqueCombos = new Array();
                    const config = {
                        locateFile: filename => `/dist/${filename}`
                    };

                    initSqlJs(config).then(function (SQL) {
                        // Pal class definition
                        class Pal {
                            constructor(tieOrder, dexNum, name, rarity, elem1, elem2, sprintSpeed, breedPower,
                                kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming) {
                                this.tieOrder = tieOrder;
                                this.dexNum = dexNum;
                                this.name = name;
                                this.rarity = rarity;
                                this.elem1 = elem1;
                                this.elem2 = elem2;
                                this.sprintSpeed = sprintSpeed;
                                this.breedPower = breedPower;

                                this.kindling = kindling;
                                this.planting = planting;
                                this.handiwork = handiwork;
                                this.lumbering = lumbering;
                                this.medicine = medicine;
                                this.transporting = transporting;
                                this.watering = watering;
                                this.genElec = genElec;
                                this.gathering = gathering;
                                this.mining = mining;
                                this.cooling = cooling;
                                this.farming = farming;
                            }

                            // Reading query as pal objects
                            static async readPals() {
                                try {
                                    const response = await fetch('../db/paldb.db');
                                    const buffer = await response.arrayBuffer();
                                    const db = new SQL.Database(new Uint8Array(buffer));
                                    const query = "SELECT pd.IndexOrder, bp.DexNum, bp.Name, pd.Rarity, pd.ElementType1, pd.ElementType2, pd.RideSprintSpeed, bp.Power, pd.WorkSuitability_EmitFlame, pd.WorkSuitability_Watering, pd.WorkSuitability_Seeding, pd.WorkSuitability_GenerateElectricity, pd.WorkSuitability_Handcraft, pd.WorkSuitability_Collection, pd.WorkSuitability_Deforest, pd.WorkSuitability_Mining, pd.WorkSuitability_ProductMedicine, pd.WorkSuitability_Cool,  pd.WorkSuitability_Transport,  pd.WorkSuitability_MonsterFarm FROM breeding_power bp JOIN pal_data pd ON bp.Name = pd.Name ORDER BY pd.IndexOrder ASC";
                                    const rows = db.exec(query);

                                    if (rows.length > 0) {

                                        rows[0].values.forEach(row => {
                                            const [tieOrder, dexNum, name, rarity, elem1, elem2, sprintSpeed, breedPower, kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming] = row;
                                            const fElem1 = elem1.replace("EPalElementType::", "").toLowerCase();
                                            const fElem2 = elem2.replace("EPalElementType::", "").toLowerCase();
                                            palArray[tieOrder - 1] = new Pal(tieOrder, dexNum, name, rarity, fElem1, fElem2, sprintSpeed, breedPower, kindling, watering, planting, genElec, handiwork, gathering, lumbering, mining, medicine, cooling, transporting, farming);
                                        });

                                        console.log(`[DEBUG] Successfully read ${palArray.length} entries`);
                                    } else {
                                        console.log("[DEBUG] ERROR: No data retrieved");
                                        throw new Error("No data retrieved");
                                    }
                                } catch (error) {
                                    console.error(error);
                                    throw error;
                                }

                                const response = await fetch('../db/paldb.db');
                                const buffer = await response.arrayBuffer();
                                const db = new SQL.Database(new Uint8Array(buffer));
                                const query = "SELECT * FROM unique_combos";
                                const rows = db.exec(query);

                                if (rows.length > 0) {
                                    rows[0].values.forEach(row => {
                                        const [parent1, parent2, child] = row;
                                        uniqueCombos.push([parent1, parent2, child]);
                                    });
                                }
                            }
                        }

                        (async function () {
                            try {
                                await Pal.readPals();
                                const palContainer = document.getElementById('palContainer');
                                let selectedPalEntry1 = null;
                                let selectedPalEntry2 = null;

                                palArray.forEach(pal => {

                                    const palEntry = document.createElement('div');
                                    palEntry.classList.add('palEntry');
                                    palEntry.id = `entry-${pal.name}`;

                                    const palImg = document.createElement('img');
                                    palImg.src = `./resource/img/pal/${pal.name}.png`;
                                    palImg.classList.add('palImg');

                                    const palName = document.createElement('div');
                                    palName.classList.add('palName');
                                    palName.textContent = pal.name;

                                    const shineBox = document.createElement('div');
                                    palEntry.classList.add('shineBox');

                                    const element = document.createElement('img');
                                    element.id = `${pal.name}.elem1`;
                                    element.src = `./resource/img/elem/${pal.elem1}.png`;
                                    element.classList.add('element', `${pal.elem1}`);

                                    if (pal.elem2 !== 'none') {
                                        const element2 = document.createElement('img');
                                        element2.id = `${pal.name}.elem2`;
                                        element2.src = `./resource/img/elem/${pal.elem2}.png`;
                                        element2.classList.add('element', 'secondary', `${pal.elem2}`);
                                        palEntry.appendChild(element2);
                                    }

                                    // Breeding power
                                    palEntry.setAttribute('data-breedPower', pal.breedPower);

                                    // new div for work plate
                                    const workPlate = document.createElement('div');
                                    workPlate.classList.add('workPlate');

                                    // Work Suitabilities
                                    const workImg = document.createElement('img');
                                    workImg.classList.add('workImg');

                                    const work_suitabilities = ['kindling', 'watering', 'planting', 'genElec', 'handiwork', 'gathering', 'lumbering', 'mining', 'medicine', 'cooling', 'transporting', 'farming'];

                                    let workImgIndex = 0;
                                    for (let i = 0; i < work_suitabilities.length; i++) {
                                        const suitabilityImg = document.createElement('img');
                                        suitabilityImg.src = `./resource/img/work/${work_suitabilities[i]}.png`;
                                        suitabilityImg.classList.add('workImg', work_suitabilities[i]);
                                        if (pal[work_suitabilities[i]] == 0) {
                                            suitabilityImg.style.filter = 'grayscale(100%)';
                                        }
                                        if (pal[work_suitabilities[i]] !== 0) {
                                            suitabilityImg.style.setProperty('--index', workImgIndex++);

                                            const workLvl = document.createElement('p');
                                            workLvl.innerText = pal[work_suitabilities[i]];

                                            workLvl.classList.add('workLvl', work_suitabilities[i]);
                                            workLvl.style.setProperty('--index', workImgIndex - 1);
                                            workPlate.appendChild(workLvl);
                                            palEntry.appendChild(suitabilityImg);
                                        }

                                    }

                                    palEntry.appendChild(palImg);
                                    palEntry.appendChild(element);
                                    palEntry.appendChild(palName);
                                    palEntry.appendChild(shineBox);
                                    palEntry.appendChild(workPlate);
                                    palContainer.appendChild(palEntry);
                                });
                                let searchWrapper1 = document.querySelector('.searchWrapper');
                                let searchWrapper2 = searchWrapper1.cloneNode(true);
                                document.body.appendChild(searchWrapper2);
                                addFilters();
                                addSelectHandlers([searchWrapper1, searchWrapper2]);
                            } catch (error) {
                                console.error(error);
                            }
                        })();
                    });
                </script>
            </div>
            <div class="filtersMenuHitbox">
                <div class="filtersMenu">
                    <div class="filtersMenuTab">
                        <p class="tabArrow">
                            &#9660;
                        </p>
                    </div>
                    <div class="hideyMan"></div>
                    <div class="filterImage">
                        <div class="filterTriangle">
                            &#x25BC;

                            <div class="filterBar">
                                &#x2758;

                            </div>
                        </div>
                    </div>
                    <div class="filtersContainer container">
                        <div class="elementFilterContainer"></div>
                        <div class="workFilterContainer"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="resultField"></div>
        <script>
            function addFilters() {
                const work_suitabilities = ['kindling', 'watering', 'planting', 'genElec', 'handiwork', 'gathering', 'lumbering', 'mining', 'medicine', 'cooling', 'transporting', 'farming'];
                const elements = ['fire', 'water', 'leaf', 'earth', 'electricity', 'normal', 'dark', 'ice', 'dragon'];

                let wrappers = document.querySelectorAll('.searchWrapper');
                wrappers.forEach(function (wrapper) {
                    let filtersContainer = wrapper.getElementsByClassName('filtersContainer')[0];
                    let elementFilterContainer = filtersContainer.getElementsByClassName('elementFilterContainer')[0];
                    let workFilterContainer = filtersContainer.getElementsByClassName('workFilterContainer')[0];

                    elements.forEach(function (elementValue) {

                        let elementFilterButton = document.createElement('img');
                        elementFilterButton.src = `./resource/img/elem/${elementValue}.png`;
                        elementFilterButton.classList.add('elementFilterButton', `${elementValue}`);

                        elementFilterButton.addEventListener('click', () => {
                            elementFilterButton.classList.toggle('selected');
                            filterResults(wrapper); // Trigger filtering algorithm
                        });


                        elementFilterContainer.appendChild(elementFilterButton);
                    });

                    work_suitabilities.forEach(function (suitability) {
                        let workFilterButtonWrapper = document.createElement('div');
                        workFilterButtonWrapper.classList.add('workFilterButtonWrapper');

                        let workFilterButton = document.createElement('img');
                        workFilterButton.src = `./resource/img/work/${suitability}.png`;
                        workFilterButton.classList.add('workFilterButton', `${suitability}`);
                        workFilterButtonWrapper.appendChild(workFilterButton);

                        workFilterButton.addEventListener('click', () => {
                            event.target.parentElement.classList.toggle('selected');
                            filterResults(wrapper);
                        });

                        let minLevelInput = document.createElement('input');
                        minLevelInput.placeholder = '0';
                        minLevelInput.maxLength = 1;
                        minLevelInput.onkeydown = function handleKeys(e) {
                            let acceptedKeys = [8, 37, 38, 39, 40, 49, 50, 51, 52];
                            if (!acceptedKeys.includes(e.keyCode)) e.preventDefault();
                            else if (this.value.length === 1 || this.value.length === 0) {
                                // e.preventDefault();
                                switch (e.keyCode) {
                                    case 8:
                                        this.value = '';
                                        break;
                                    case 39:
                                    case 38:
                                        if (parseInt(this.value) < 4) this.value = parseInt(this.value) + 1;
                                        else if (this.value.length === 0) this.value = 1;
                                        break;
                                    case 37:
                                    case 40:
                                        if (parseInt(this.value) > 1) this.value = parseInt(this.value) - 1;
                                        else if (parseInt(this.value) === 1) this.value = '';
                                        break;
                                }
                            };
                        };

                        minLevelInput.addEventListener('keydown', () => {
                            if (event.target.parentElement.classList.contains('selected')) filterResults(wrapper);
                        })

                        minLevelInput.classList.add('minLevelInput', `${suitability}`);
                        workFilterButtonWrapper.appendChild(minLevelInput);
                        workFilterContainer.appendChild(workFilterButtonWrapper);
                    });

                })
            }
        </script>
        <script>
            function filterResults(wrapper) {
                console.log('[DEBUG] filtering entries');
                let input, filter, palContainer, palEntries, i;
                input = wrapper.getElementsByClassName("searchBox")[0];
                filter = input.value.toUpperCase();
                palContainer = wrapper.getElementsByClassName("palContainer")[0];
                palEntries = palContainer.getElementsByClassName("palEntry");
                let selectedElements = wrapper.querySelectorAll('.elementFilterButton.selected');
                let selectedWorkFilters = wrapper.querySelectorAll('.workFilterButtonWrapper.selected');

                for (i = 0; i < palEntries.length; i++) {
                    let currEntry = palEntries[i];
                    let palName = currEntry.getElementsByClassName("palName")[0];
                    let txtValue = palName.textContent || palName.innerText;
                    let shouldDisplay = true;
                    let conditions = [];

                    // Check if the pal entry matches the search filter
                    if (txtValue.toUpperCase().indexOf(filter) === -1) {
                        conditions.push(false);
                    }

                    // Filter by element
                    selectedElements.forEach(selectedElement => {
                        let elem1 = currEntry.getElementsByClassName(`element`)[0];
                        let elem2 = currEntry.getElementsByClassName(`element`)[1];

                        if (!(elem1 && elem1.classList.contains(selectedElement.classList[1])) &&
                            !(elem2 && elem2.classList.contains(selectedElement.classList[1]))) {
                            conditions.push(false);
                        }
                    });

                    // Filter by work suitability + level
                    // For each wrapper, get its type and minimum level - DONE
                    // Then, compare that min level to the current palEntry's level for that type - DONE
                    // Set shouldDisplay accordingly - WIP, Currently operates only based on most recent one, collect all into an array and if any are false, set false
                    let currPal = palEntries[i];
                    let workPlate = currPal.getElementsByClassName('workPlate')[0];
                    selectedWorkFilters.forEach(workWrapper => {
                        let inputBox = workWrapper.getElementsByClassName('minLevelInput')[0];
                        let minLvl = inputBox.value;
                        if (!inputBox.value) minLvl = 0;

                        // TODO SECOND HALF OF FILTERING LOGIC
                        let workEntry = workPlate.getElementsByClassName(`${inputBox.classList[1]}`);
                        workEntry = workEntry[0];
                        // If this palEntry has the following selected workType
                        if (workEntry) {
                            let workLvl = workEntry.textContent;
                            if (workLvl >= minLvl) conditions.push(true);
                            else conditions.push(false);
                        } else {
                            conditions.push(false);
                        }
                    });

                    // Display entry if it contains adequate levels
                    if (conditions.includes(false)) shouldDisplay = false;

                    // Update the display of the pal entry
                    if (shouldDisplay) {
                        palEntries[i].style.display = "";
                    } else {
                        palEntries[i].style.display = "none";
                    }
                }
            }

        </script>
        <script>
            function addSelectHandlers(wrappers) {
                wrappers.forEach(function (wrapper, i) {
                    let palContainer = wrapper.getElementsByClassName("palContainer")[0];
                    let palEntries = Array.from(palContainer.getElementsByClassName("palEntry"));
                    palEntries.forEach(palEntry => {

                        palEntry.addEventListener('click', () => {
                            const currentPalEntry = event.currentTarget;
                            currentPalEntry.classList.toggle('selected');
                            let selectedPalEntry = eval(`this.selectedPalEntry${i + 1}`);
                            if (selectedPalEntry && selectedPalEntry !== currentPalEntry) {
                                selectedPalEntry.classList.remove('selected');
                            }

                            selectedPalEntry = currentPalEntry.classList.contains('selected') ? currentPalEntry : null;
                            if (i == 0) {
                                selectedPalEntry1 = selectedPalEntry;
                            } else {
                                selectedPalEntry2 = selectedPalEntry;
                            }
                            console.log(`[DEBUG] 1: ${this.selectedPalEntry1} | 2: ${this.selectedPalEntry2}`);
                            calculateResult();
                        });
                    });
                });
            }
        </script>
        <script>
            function removeFadeOut(element) {
                element.classList.add('removed');
                setTimeout(function () {
                    element.parentNode.removeChild(element);
                }, 80);
            }

            // Array of combos (Length 3 array of parent1, parent2, and child)
            // Pass in parent1 and parent2 as palNames (strings), return null if not unique combo
            function getUniqueCombo(parent1, parent2) {
                let result = null;
                uniqueCombos.forEach((combo) => {
                    let parents = [combo[0], combo[1]];
                    if ((parents[0] === parent1 && parents[1] === parent2) || (parents[0] === parent2 && parents[1] === parent1)) {
                        result = combo[2];
                    }
                });

                return result;
            }

            function calculateResult() {
                let field = document.getElementsByClassName('resultField')[0];
                let selectedPals = [];
                selectedPals = Array.from(document.getElementsByClassName('palEntry selected'));
                let childName = '';

                // Two pals have NOT yet been selected
                console.log('Children: ', field.children[0]);
                if (selectedPals.length < 2) {
                    if (field.childElementCount > 0) {
                        removeFadeOut(field.children[0]);
                    }
                }
                // Two pals have been selected
                else {
                    let palNames = [selectedPals[0].getElementsByClassName('palName')[0].textContent, selectedPals[1].getElementsByClassName('palName')[0].textContent];
                    let unique;
                    unique = getUniqueCombo(palNames[0], palNames[1]);
                    if (unique) childName = unique;
                    else {
                        let breedPowers = selectedPals.map((palEntry) => palEntry.getAttribute('data-breedPower'));
                        let resultBreedPower = Math.floor((parseInt(breedPowers[0]) + parseInt(breedPowers[1]) + 1) / 2);

                        let allBreedPowers = palArray.map((pal) => pal.breedPower);

                        let nearest = allBreedPowers.reduce(function (prev, curr) {
                            return (Math.abs(curr - resultBreedPower) < Math.abs(prev - resultBreedPower) ? curr : prev);
                        });
                        childName = palArray[allBreedPowers.indexOf(nearest)].name;
                    }
                    if (field.childElementCount > 0) {
                        removeFadeOut(field.children[0]);
                    }
                    console.log(childName);

                    let childEntry = document.getElementById(`entry-${childName}`).cloneNode(true);
                    if (childEntry.classList.contains('selected')) {
                        childEntry.classList.toggle('selected');
                    }
                    childEntry.classList.toggle('result');
                    childEntry.style.display = 'block';
                    field.appendChild(childEntry);
                }
            }
        </script>
    </body>

</html>